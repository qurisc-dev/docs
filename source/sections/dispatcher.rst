Dispatcher
========

Dispatcher与前端相连，将前端的指令分发到ROB、保留站、重命名站等若干位置。

发射条件
--------
Dispatcher需要保证所有的条件都满足时，才能向后端发射指令：

- rs_ready：保留站中存在空闲的本指令需要的FU。
- rob_ready：ROB没有被填满。
- store_queue_available：对于Store指令，SQ中必须有空闲项。
- load_queue_available：对于Load指令，LQ中必须有空闲项。
- rob_empty：有一些指令（例如CSR操作指令）需要在为ROB空的时候才能发射。
- no_immediate_cancel：下面一条指令不会立刻被重发射。当开始重发射时，不再发射该条指令。

重发射相关
--------
当Dispatcher接收到要求重发射的信号时，Dispatcher会停止从前端接收指令而从ROB接收指令，并且将其原样发射给ROB等元件。
Dispatcher需要接收start_reissue信号以阻止一次发射，并且接收reissue信号以确定从ROB接收重发射指令。

寄存器依赖与值的确定
--------
Dispatcher通过复杂的组合逻辑确定指令的寄存器依赖关系和已知的值，并将其转交给保留站、ROB和寄存器重命名站。

- 如果操作数为常数（PC、Immediate），则操作数已知。
- 如果操作数所涉及的寄存器在重命名站里没有被重命名，则操作数在寄存器堆中。因为此时向寄存器堆的提交操作不可能指向这个寄存器。
- 如果操作数所涉及的寄存器在重命名站里被重命名，则依赖关系已知，操作数在ROB中，可能就绪或者未就绪。此时即使操作数即将被提交，其值也在ROB中；但是，依赖关系需要除去即将被提交的表项。
- 目标寄存器的依赖关系为两个操作数的依赖关系去除即将提交的依赖关系。假如即将提交的条目需要被重发射，那么新发射的指令也需要重发射。无论如何，Dispatcher不再发射该条指令，而是在下一个周期直接开始重发射。
- 在寄存器请求（Qs、Qt）写入保留站时，如果CDB恰巧有输出，则直接使用CDB中的值。

以上组合逻辑的critical path在于操作数——重命名站发现已重命名 ——ROB查询获得编号——保留站CDB覆盖，可能会造成较大的门延迟。
该组合逻辑在100MHz下无法满足时间约束，故我们以空间换时间，将寄存器堆复制一份，跳过对ROB的查询操作，而是从复制的寄存器堆获得操作数。